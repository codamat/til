# コストマネジメント（Cost Management）


計画・設計・施工・運用など全ライフサイクルの費用（コスト）を最小限に抑えつつ、品質を確保・最大化するために、**予算策定、コスト見積もり、進捗コントロール**、改善活動を行う一連の管理プロセス。

## 主要プロセス
1. 立ち上げ： 
2. **計画：** 
   - **コスト見積もり**: 活動に必要なコストを算出。
   - **予算設定**: 見積もりを基に、確定した予算を策定。
1. 実行： 
2. **コントロール:** 実際のコストと予算を比較・分析し、必要に応じて修正対応を行う。
3. 終結：

**主なポイント**

- **目的**: 承認された予算内でプロジェクトを完了させ、利益を最大化する。
- **ライフサイクル全体**: 企画・設計から製造、廃棄に至るまでのコストを対象にする。
- **主なプロセス**: 計画プロセス群（予算設定など）と監視・コントロールプロセス群（実績と予算の対比・調整）に分かれる。

## 見積もり手法
プロジェクトのフェーズや情報の精度に応じて使い分けられる。

### 1. 類推見積もり（Analogous Estimating） 

**過去の似たプロジェクトをもとに**、今回のコストを概算で予測する手法。 

- **特徴**: プロジェクト初期の、情報が少ない段階で素早く行えますが、精度は低め。
- **向いている場面**: 企画段階のざっくりとした予算把握。 

> [!NOTE] 出題例：
> **過去に経験した類似の**ソフトウェアについてのデータを基にして、ソフトウェアの相違点を調べ、同じ部分については過去のデータを使い、異なった部分は経験に基づいて、規模と工数を見積る方法である


### 2. プログラムステップ法

別名**LOC法**（Lines of Code）
プログラムを構成するソースコードの**行数**（ステップ数）を基準にして、開発にかかる工数やコストを算出。 

- **計算の仕組み**: `予想される総ステップ数 × 1ステップあたりの単価（または時間）`。

| メリット                                    | デメリット                                     |
| --------------------------------------- | ----------------------------------------- |
| **客観的な数値**で計算するため、計算の根拠が明確で誰でも同じ結果が出せる。 | **プログラミング言語やスキル**によって行数が変わるため、精度が左右されやすい。 |
| 過去に似た言語での実績があれば、**高い精度で予測**が可能。         | **コードを書く前**（設計段階）では、正確な行数を予測するのが難しい。      |


### 3. パラメトリック見積もり（Parametric Estimating） 

統計的な関係（係数）を用いて算出する手法です。例えば、「1平方メートルあたり単価 × 面積」のように計算。 

- **特徴**: データの精度が高ければ、**類推見積もりよりも正確な予測が可能**。
- **向いている場面**: 建築の坪単価や、IT開発のプログラム本数（ファンクションポイント法）など。 

### 4. ボトムアップ見積もり（Bottom-up Estimating）

別名**積算法**
作業を細かく（WBS単位など）分解し、それぞれのコストを積み上げて全体の総額を出す手法。 

- **特徴**: 最も精度が高いが、詳細な計画が必要なため時間と手間がかかる。
- **向いている場面**: 実施計画が固まった後の、詳細な予算設定。 

> [!NOTE] 出題例：
> 単位作業項目に通用する作業量の基準値を決めておき、作業項目を単位作業項目まで分解し、基準値を適用して算出した作業量の**積算**で全体の作業量を見積もる方法である。


### 5. 三点見積もり（Three-Point Estimating） 

リスクを考慮し、「最良（楽観値）」「最悪（悲観値）」「最も可能性が高い（最頻値）」の3つのシナリオで見積もり、その平均をとる手法。 

- **算出式（PERT手法）**: `(楽観値 + 4×最頻値 + 悲観値) ÷ 6`
- **特徴**: 不確実性が高い項目に対して、リスクを数値化して反映。 

### 6. COCOMO （Constructive Cost Model） 

- **仕組み**: 基本的には「プログラムの行数（KLOC：千行単位）」をベースに、**補正係数**を掛け合わせる。
- **補正係数の例**:
    - エンジニアの技術力
    - ソフトウェアの信頼性の要求度
    - 開発環境の性能
    - スケジュールの厳しさ

> [!NOTE] 出題例：
> 開発規模がわかっていることを前提として、工期と工数を見積る方法。
> ビジネス分野に限らず、**全分野に適用可能**である。


#### COCOMO II（ココモ ツー） 

現在は、現代の開発スタイル（オブジェクト指向や再利用など）に合わせて改良された**COCOMO II**が主流。単なる行数だけでなく、設計の初期段階でも見積もれるよう工夫されている。

### 7. **ファンクションポイント（FP）法**

プログラムの「行数」ではなく、ユーザーから見た**機能（ファンクション）」の数や複雑さ**で価値を測る。

#### ファンクションタイプ

1. **外部入力**: データの登録や更新画面の数
2. **外部出力**: 帳票やレポート、メール送信の数
3. **外部照会**: 画面での検索や表示の数
4. **内部論理ファイル**: システム内のデータベース（テーブル）の数
5. **外部インターフェース**: 他のシステムと連携するデータの数

#### 見積もりの手順

1. **要素のカウント**: 上記5項目がそれぞれいくつあるか数える。
2. **複雑さの重み付け**: 各項目を「低・中・高」の難易度で評価し、点数（ポイント）をつける。
3. **補正係数の適用**: 通信の複雑さや処理の速さなど、システム全体の特性を考慮して微調整する。
4. **工数への変換**: 合計ポイントに、自社の過去の実績（1ポイントあたり○人月）を掛けて最終的なコストを出す。

#### FP法のメリットとデメリット

|メリット|デメリット|
|---|---|
|**ユーザーに分かりやすい**: 「この画面とこの機能を作るからこの値段です」と説明に納得感がある。|**判定に専門知識が必要**: どこまでを1つの機能と数えるか、判断に慣れが必要。|
|**言語に依存しない**: Javaで作ってもPythonで作っても、機能が同じなら見積もりも同じになる。|**内部処理が見えにくい**: 画面には出ないが非常に複雑な計算アルゴリズムなどは過小評価されやすい。|
|**設計段階で使える**: コードを書く前（要件定義が終わった段階）で見積もりが可能。||

---

### 見積もり手法の比較

- **プログラムステップ法**: 「何行書くか？」（つくる側の視点）
- **COCOMO**: 「何行書くか？ ＋ チームの能力は？」（つくる側の視点＋環境）
- **ファンクションポイント法**: 「何ができるか？」（**使う側**の視点）


**【その他の手法の使い分け】**

- **スピード重視（初期）**: 類推見積もり
- **データ活用（中期）**: パラメトリック見積もり
- **精度重視（実行前）**: ボトムアップ見積もり


> [!TIP]  
> 最近の開発現場では、**ファンクションポイント法で全体の規模を測り、ボトムアップ（積算法）で作業の具体性を確認する**というように、複数の手法を組み合わせて精度を高めるのが一般的。

